import { error } from 'console';
import { App, Editor, MarkdownView, Modal, Notice, Plugin, PluginSettingTab, Setting, normalizePath } from 'obsidian';

// Remember to rename these classes and interfaces!

interface ContactsPluginSettings {
	contactsFolder: string;
	autogenerationSeparator: string
}

const DEFAULT_SETTINGS: ContactsPluginSettings = {
	contactsFolder: 'Contacts',
	autogenerationSeparator: "<!-- Content above this line is AUTOGENERATED and will be REPLACED. -->"
}

export default class ContactsPlugin extends Plugin {
	settings: ContactsPluginSettings;

	async onload() {
		await this.loadSettings();

		// This adds a simple command that can be triggered anywhere
		this.addCommand({
			id: 'sync-contacts',
			name: 'Syncs contacts',
			callback: async () =>  {
				if (await this.app.vault.adapter.exists(normalizePath(this.settings.contactsFolder)) == false) {
					await this.app.vault.createFolder(this.settings.contactsFolder);
				}

				let markdownResults = LoadContactsLogic.loadContacts();
				let markdownFiles = this.app.vault.getMarkdownFiles()
					.filter(file => file.path.startsWith(this.settings.contactsFolder));


				let promises: Array<Promise<any>> = [];
				for (let [filename, markdown] of markdownResults) {
					let prom: Promise<any>;
					let normPath = normalizePath(`${this.settings.contactsFolder}/${filename}.md`);

					if (await this.app.vault.adapter.exists(normPath)) {
						let file = markdownFiles.find(file => file.path == normPath);
						if (file == undefined)
							continue;
						console.debug(`Updating ${filename}`);
						prom = this.app.vault.process(file, (oldContent) => {
							let lines = oldContent.split("\n");
							var autogenerationSeparatorIndex : number = -2;
							for (let i = 0; i < lines.length; i++) {
								if (lines[i].contains(this.settings.autogenerationSeparator)) {
									autogenerationSeparatorIndex = i;
									break;
								}
							}

							var newContent = markdown + "\n\n" + this.settings.autogenerationSeparator + "\n";
							newContent += lines.slice(autogenerationSeparatorIndex + 1).join("\n");
							
							return newContent;
						});
					} else {
						console.debug(`Creating ${filename}`);
						prom = this.app.vault.create(`${this.settings.contactsFolder}/${filename}.md`, markdown + "\n\n" + this.settings.autogenerationSeparator);
					}
					if (prom != undefined) {
						prom.catch((error) => {
							console.error(`Error syncing ${filename}`);
							console.error(error);
						});
						promises.push(prom);
					}
				}

				Promise.all(promises).then(() => {
					new Notice("Contacts synced!");
				}).catch((error) => {
					new Notice("Error syncing contacts!");
					console.error(error);
				});
			}
		});

		// This adds a settings tab so the user can configure various aspects of the plugin
		this.addSettingTab(new SettingTab(this.app, this));

		// If the plugin hooks up any global DOM events (on parts of the app that doesn't belong to this plugin)
		// Using this function will automatically remove the event listener when this plugin is disabled.
		this.registerDomEvent(document, 'click', (evt: MouseEvent) => {
			console.log('click', evt);
		});

		// When registering intervals, this function will automatically clear the interval when the plugin is disabled.
		this.registerInterval(window.setInterval(() => console.log('setInterval'), 5 * 60 * 1000));
	}

	onunload() {

	}


	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class LoadedContactsModal extends Modal {
	text: string;

	constructor(app: App, text: string) {
		super(app);
		this.text = text;
	}

	onOpen() {
		const {contentEl} = this;
		contentEl.setText(this.text);
	}

	onClose() {
		const {contentEl} = this;
		contentEl.empty();
	}
}

class SettingTab extends PluginSettingTab {
	plugin: ContactsPlugin;

	constructor(app: App, plugin: ContactsPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const {containerEl} = this;

		containerEl.empty();

		new Setting(containerEl)
			.setName('Contacts Folder')
			.setDesc('Select the folder in which your contacts will stored')
			.addText(text => text
				.setPlaceholder('contacts')
				.setValue(this.plugin.settings.contactsFolder)
				.onChange(async (value) => {
					this.plugin.settings.contactsFolder = value;
					await this.plugin.saveSettings();
				}));
	}
}

interface VCard {
	fn?: { value: string }[];
	org?: { value: string[] }[];
	email?: { value: string, meta: { type: string[] } }[];
	tel?: { value: string, meta: { type: string[] } }[];
	adr?: { value: string[], meta: { type: string[] } }[];
	note?: { value: string }[];
	url?: { value: string, meta: { type: string[] }, namespace?: string }[];
	bday?: { value: string }[];
	categories?: { value: string }[];
	uid?: { value: string }[];
  }

class LoadContactsLogic {
	static loadContacts(): Map<string, string> {
		let vcard_data = this.get_vcards_string_from_applescript();
  		let vcards = this.process_vcards_string(vcard_data);
		
		let markdownMap = new Map<string, string>();

		for (let vcard of vcards) {
			let filename = vcard.fn?.[0]?.value;
			if (filename == undefined)
				continue;
		
			let markdown = this.vcardToMarkdown(vcard);

			markdownMap.set(filename, markdown);
		}

		return markdownMap;
	}

	private static get_vcards_string_from_applescript(): string {
		const { spawnSync } = require('child_process');

		const group = "obsidian";
		const outputFolder = "Contacts";

		const APPLESCRIPT = `
			set AppleScript's text item delimiters to ""

			tell application "Contacts"

			if not running then
				run
				delay 4
			end if

			set vCardText to (get vcard of every person in group "${group}") as text

			end tell
		`;

		var cmd = spawnSync('osascript', ['-e', APPLESCRIPT]);

		if(cmd.status != 0) {
			console.error(`Status: ${cmd.status} | Error: ${cmd.stderr}`);
			throw new Error(cmd.error);
		}

		return cmd.stdout.toString();
	}
	
	private static process_vcards_string(vcard_data: string): Array<VCard> {
		const vCard = require("vcard-parser");

		const regex = /BEGIN:VCARD[\s\S]*?END:VCARD/g;
		const matches = vcard_data.match(regex);
		let vCards: Array<VCard> = [];

		if (matches) {
			matches.forEach((match, index) => {
				vCards.push(vCard.parse(match) as VCard);
			});
		}

		return vCards;
	}

	private static vcardToMarkdown(vcard: VCard): string {
		if (vcard.fn![0]!.value == "Luca Michael Johannes Beetz")
			console.log(vcard);

		let markdown = `## üë§ ${vcard.fn?.[0]?.value ?? 'Unknown'}\n`;
	  
		if (vcard.tel) markdown += vcard.tel.map(tel => `- ‚òéÔ∏è ${tel.meta?.type?.[0]?.toLowerCase() ?? 'Phone'}: [${tel.value}](tel:${tel.value})\n`).join('');
		if (vcard.email) markdown += `- üìß Email: [${vcard.email[0]?.value}](mailto:${vcard.email[0]?.value})\n`;
		if (vcard.url) markdown += `- üåê Website: [${vcard.url[0]?.value}](${vcard.url[0]?.value})\n`;
		if (vcard.adr) markdown += vcard.adr.map(adr => `- üè† Address: ${adr.value.filter(str => str.length > 0).join(", ")}\n`).join(''); // Joining address components by ', '
		if (vcard.bday) {
		  	const date = new Date(Date.parse(vcard.bday[0]?.value));
			markdown += `- üéÇ Birthday: ${date.toLocaleDateString()}\n`;
		}
		if (vcard.org) markdown += `- üè¢ Organization: ${vcard.org[0]?.value?.[0]}\n`;
		if (vcard.note) {
			let notes_lines = vcard.note[0]?.value.split("\n");
			markdown += `- üìù Notes: ${notes_lines[0]}\n`;
			for ( let line of notes_lines.slice(1))
				markdown += `\t${line}\n`;
		}
		//if (vcard.x_anniversary) markdown += `- üíç Anniversary: [[${vcard.x_anniversary[0]?.value}]]\n`; // Make sure this field exists in your VCard interface
		//if (vcard.geo) markdown += `- üìç Location: ${vcard.geo[0]?.value}\n`;
		//if (vcard.role) markdown += `- üíº Role: ${vcard.role[0]?.value}\n`;
		//if (vcard.title) markdown += `- üìõ Title: ${vcard.title[0]?.value}\n`;
		
		//if (vcard.x_gender) {
		//  const genderEmoji = vcard.x_gender[0]?.value?.toLowerCase() === 'f' ? "\u2640\ufe0f" : "\u2642\ufe0f";
		//  markdown += `- ${genderEmoji} Gender: ${vcard.x_gender[0]?.value}\n`;
		//}
	  
		//if (vcard.lang) markdown += `- üó£Ô∏è Language: ${vcard.lang[0]?.value}\n`;
	  
		return markdown.trim();
	}
	  
}