import { App, Notice, Platform, Plugin, PluginSettingTab, Setting, TFile, TFolder, normalizePath } from 'obsidian';
const vCardParser = require('vcard-parser');
const { spawn } = require('child_process');


interface ContactsPluginSettings {
	contactsGroup: string;
	contactsFolder: string;
	autogenerationStartTag: string
	autogenerationStartText: string
	autogenerationEndTag: string
	autogenerationEndText: string
}

interface VCard {
	fn?: { value: string }[];
	org?: { value: string[] }[];
	email?: { value: string, meta: { type: string[] } }[];
	tel?: { value: string, meta: { type: string[] } }[];
	adr?: { value: string[], meta: { type: string[] } }[];
	note?: { value: string }[];
	url?: { value: string, meta: { type: string[] }, namespace?: string }[];
	bday?: { value: string }[];
	categories?: { value: string }[];
	uid?: { value: string }[];
}

class SettingTab extends PluginSettingTab {
	plugin: ContactsPlugin;

	constructor(app: App, plugin: ContactsPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const {containerEl} = this;

		containerEl.empty();

		new Setting(containerEl)
			.setName('Contacts folder')
			.setDesc('Select the folder in which your contacts will stored')
			.addText(text => text
				.setPlaceholder('Contacts')
				.setValue(this.plugin.settings.contactsFolder)
				.onChange(async (value) => {
					this.plugin.settings.contactsFolder = value;
					await this.plugin.saveSettings();
				}));
		
		new Setting(containerEl)
			.setName('Contacts group')
			.setDesc('Enter the name of the group ("Smart List") in which your contacts are stored in the MacOS Contacts app')
			.addText(text => text
				.setPlaceholder('Obsidian')
				.setValue(this.plugin.settings.contactsGroup)
				.onChange(async (value) => {
					this.plugin.settings.contactsGroup = value;
					await this.plugin.saveSettings();
				}));
	}
}

const DEFAULT_SETTINGS: ContactsPluginSettings = {
	contactsGroup: 'Obsidian',
	contactsFolder: 'Contacts',
	autogenerationStartTag: "START",
	autogenerationStartText: "Content BELOW this line is AUTOGENERATED and will be REPLACED.",
	autogenerationEndTag: "END",
	autogenerationEndText: "Content ABOVE this line is AUTOGENERATED and will be REPLACED."
}

export default class ContactsPlugin extends Plugin {
	settings: ContactsPluginSettings;

	async onload() {
		await this.loadSettings();

		// This adds a simple command that can be triggered anywhere
		this.addCommand({
			id: 'sync-contacts',
			name: 'Sync contacts',
			callback: async () =>  {
				if (!Platform.isMacOS) 
					return new Notice("Error: This plugin only works on MacOS");

				// Find/Create contacts folder
				if (await this.app.vault.adapter.exists(normalizePath(this.settings.contactsFolder)) == false)
					await this.app.vault.createFolder(this.settings.contactsFolder);

				new Notice('Syncing...')
				
				const loadContactsLogic = new LoadContactsLogic(this.settings)

				let numberOfFoundContacts = await loadContactsLogic.getNumberOfContactsInGroup();
				new Notice(`Found ${numberOfFoundContacts} Contacts in group ${this.settings.contactsGroup}`)

				// Load contacts from MacOS "Contacts"
				let markdownResults = await loadContactsLogic.loadContacts();

				// Save all contacts into file
				let successfulContacts = 0
				let promises: Array<Promise<any>> = [];
				for (let [filename, markdown] of markdownResults) {
					// Setup File
					let normPath = normalizePath(`${this.settings.contactsFolder}/${filename}.md`);
					let contactFile = this.app.vault.getAbstractFileByPath(normPath);
					let newContactInfo = `<!-- ${this.settings.autogenerationStartTag} ${this.settings.autogenerationStartText} --> \n${markdown} \n<!-- ${this.settings.autogenerationEndTag} ${this.settings.autogenerationEndText} -->`;
					
					// contactFile is a folder 
					if (contactFile instanceof TFolder) {
						console.error(`Error: ${filename} is a folder`);
						new Notice(`Error: ${filename} is a folder`);
					// contactFile doesn't exist yet
					} else if (contactFile === null) {
						promises.push(
							this.app.vault.create(normPath, newContactInfo)
							.then((_) => successfulContacts++)
							.catch((error) => console.error(`Error syncing ${filename}\n${error}`))
						);
					// contactFile exists
					} else if (contactFile instanceof TFile) {
						promises.push(
							// extract the old contact info and replace it with the new data
							this.app.vault.process(contactFile, (oldContent) => {
								let lines = oldContent.split("\n");
								
								let startReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationStartTag));
								let endReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationEndTag));

								let newLines = Array<string>();

								for (let i = Math.min(0, startReplacementIndex); i < lines.length; i++) {
									if (i == startReplacementIndex) {
										newLines.push(newContactInfo);
									} else if (i >= startReplacementIndex && i <= endReplacementIndex) {
										continue;
									} else {
										newLines.push(lines[i]);
									}
								}
								return newLines.join("\n");							
							})
							.then((_) => successfulContacts++)
							.catch((error) => console.error(`Error syncing ${filename}\n${error}`))
						);
					}
				}

				Promise.all(promises)
				.catch((error) => {
					new Notice("Error syncing contacts!");
					console.error(error);
				}).finally(() => {
					new Notice(`Successfully synced ${successfulContacts} of ${numberOfFoundContacts} Contacts`)
					console.info(`Successfully synced ${successfulContacts} of ${numberOfFoundContacts} Contacts`)
				});
			}
		});


		// This adds a settings tab so the user can configure various aspects of the plugin
		this.addSettingTab(new SettingTab(this.app, this));
	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class LoadContactsLogic {
	constructor(
		private settings: ContactsPluginSettings
	) {
		this.settings = settings;
	}

	async loadContacts(): Promise<Map<string, string>> {
		// Get vCards from Contacts
		let vCards: VCard[] = await this.getVCardStringsFromContactsApp();
		// Inform user of any vCards without names
		vCards.forEach((vcard) => {
			if (vcard.fn?.[0]?.value == undefined) {
				console.debug(`Found vCard without name: \n ${JSON.stringify(vcard, null, 2)}`);
				new Notice('Contact without name found. Check developer console for details.')
			}
		});
		// Filter out vCards without names
		vCards = vCards.filter((vcard) => {
			return vcard.fn?.[0]?.value != undefined;
		});

		let filenameToMarkdown = new Map<string, string>();
		for (let vcard of vCards) {
			let filename = vcard.fn![0].value!;
			let markdown = this.vcardToMarkdown(vcard);

			filenameToMarkdown.set(filename, markdown);
		}

		return filenameToMarkdown;
	}

	getNumberOfContactsInGroup(): Promise<number> {
		const groupName = this.settings.contactsGroup;
		const GROUP_NOT_DEFINED_ERROR = "GROUP NOT DEFINED";
		

		const JXA_SCRIPT = `
			let Contacts = Application('Contacts');
			Contacts.includeStandardAdditions = true;

			let groups = Contacts.groups.whose({ name: '${groupName}'});
			if (groups.length === 0 || groups === undefined || groups === null)
			 	throw new Error('${GROUP_NOT_DEFINED_ERROR}');

			groups[0].people.length;
		`;

		return new Promise((resolve, reject) => {
			// Start JXA Script
			const osascript = spawn('osascript', ['-l', 'JavaScript', '-e', JXA_SCRIPT]);
			
			// Handle JXA Script output (number of contacts in list)
			osascript.stdout.on('data', (data: number) => {
				resolve(data)
			});
	
			osascript.stderr.on('data', (data: Buffer) => {
				const errorMsg = data.toString('utf-8');

				if (errorMsg.includes(GROUP_NOT_DEFINED_ERROR)) {
					console.error(`Group "${groupName}" not found in Contacts app - JXA Script Error: ${errorMsg} `);
					reject(new Error(GROUP_NOT_DEFINED_ERROR));
					new Notice(`Error: Group "${groupName}" not found in Contacts app.`);
					return;
				}

				new Notice(`Error retrieving contacts: \n${data}`);
			});
		});
	}

	getVCardStringsFromContactsApp(): Promise<VCard[]> {
		const groupName = this.settings.contactsGroup;
		const GROUP_NOT_DEFINED_ERROR = "GROUP NOT DEFINED";
		

		const JXA_SCRIPT = `
			ObjC.import('Foundation');
			const stdout = $.NSFileHandle.fileHandleWithStandardOutput;

			let Contacts = Application('Contacts');
			Contacts.includeStandardAdditions = true;

			let groups = Contacts.groups.whose({ name: '${groupName}'});
			if (groups.length === 0 || groups === undefined || groups === null)
			 	throw new Error('${GROUP_NOT_DEFINED_ERROR}');

			for (let vcard of groups[0].people.vcard()) {
				// Write to stdout
				const nsString = $.NSString.alloc.initWithUTF8String(vcard);
				const data = nsString.dataUsingEncoding($.NSUTF8StringEncoding);
				stdout.writeData(data);
			}
		`;

		return new Promise((resolve, reject) => {
			// Start JXA Script
			const osascript = spawn('osascript', ['-l', 'JavaScript', '-e', JXA_SCRIPT]);
			
			let vCardStrBuffer = "";
			const vCards: Array<VCard> = [];
			// Handle JXA Script output (vCard strings)
			osascript.stdout.on('data', (data: Buffer) => {
				vCardStrBuffer += data.toString('utf-8');
				// Check if vCard is complete
				const regex = /BEGIN:VCARD[\s\S]*?END:VCARD/g;
				const matches = vCardStrBuffer.match(regex);
				for (let match of matches ?? []) {
					const vCard = vCardParser.parse(match) as VCard;
					vCards.push(vCard);
				}
				vCardStrBuffer = vCardStrBuffer.replace(regex, "");
			});
	
			osascript.stderr.on('data', (data: Buffer) => {
				const errorMsg = data.toString('utf-8');

				if (errorMsg.includes(GROUP_NOT_DEFINED_ERROR)) {
					console.error(`Group "${groupName}" not found in Contacts app - JXA Script Error: ${errorMsg} `);
					reject(new Error(GROUP_NOT_DEFINED_ERROR));
					new Notice(`Error: Group "${groupName}" not found in Contacts app.`);
					return;
				}

				new Notice(`Error retrieving contacts: \n${data}`);
			});
	
			osascript.on('close', (code: any) => {
				if ((vCardStrBuffer = vCardStrBuffer.trim()).length > 0) {
					console.error(`JXA Script Error: Possibly Incomplete vCard: ${vCardStrBuffer}`);
					console.debug(`Leftover vCardBuffer Length: ${vCardStrBuffer.length}`);
				}
				resolve(vCards);
			});
		});
	}

	vcardToMarkdown(vcard: VCard): string {
		let markdown = `## 👤 ${vcard.fn?.[0]?.value ?? 'Unknown'}\n`;
	  
		if (vcard.tel) markdown += vcard.tel.map(tel => `- ☎️ ${tel.meta?.type?.[0]?.toLowerCase() ?? 'Phone'}: [${tel.value}](tel:${tel.value})\n`).join('');
		if (vcard.email) markdown += `- 📧 Email: [${vcard.email[0]?.value}](mailto:${vcard.email[0]?.value})\n`;
		if (vcard.url) markdown += `- 🌐 Website: [${vcard.url[0]?.value}](${vcard.url[0]?.value})\n`;
		if (vcard.adr) markdown += vcard.adr.map(adr => `- 🏠 Address: ${adr.value.filter(str => str.length > 0).join(", ")}\n`).join(''); // Joining address components by ', '
		if (vcard.bday) {
		  	const date = new Date(Date.parse(vcard.bday[0]?.value));
			markdown += `- 🎂 Birthday: ${date.toLocaleDateString()}\n`;
		}
		if (vcard.org) markdown += `- 🏢 Organization: ${vcard.org[0]?.value?.[0]}\n`;
		if (vcard.note) {
			let notes_lines = vcard.note[0]?.value.split("\n");
			markdown += `- 📝 Notes: ${notes_lines[0]}\n`;
			for ( let line of notes_lines.slice(1))
				markdown += `\t${line}\n`;
		}
		//if (vcard.x_anniversary) markdown += `- 💍 Anniversary: [[${vcard.x_anniversary[0]?.value}]]\n`; // Make sure this field exists in your VCard interface
		//if (vcard.geo) markdown += `- 📍 Location: ${vcard.geo[0]?.value}\n`;
		//if (vcard.role) markdown += `- 💼 Role: ${vcard.role[0]?.value}\n`;
		//if (vcard.title) markdown += `- 📛 Title: ${vcard.title[0]?.value}\n`;
		
		//if (vcard.x_gender) {
		//  const genderEmoji = vcard.x_gender[0]?.value?.toLowerCase() === 'f' ? "\u2640\ufe0f" : "\u2642\ufe0f";
		//  markdown += `- ${genderEmoji} Gender: ${vcard.x_gender[0]?.value}\n`;
		//}
	  
		//if (vcard.lang) markdown += `- 🗣️ Language: ${vcard.lang[0]?.value}\n`;
	  
		return markdown.trim();
	}
	  
}