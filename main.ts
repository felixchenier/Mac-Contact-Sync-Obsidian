import { App, Notice, Platform, Plugin, PluginSettingTab, Setting, TFile, normalizePath } from 'obsidian';
const { spawn } = require('child_process');

interface ContactsPluginSettings {
	contactsGroup: string;
	contactsFolder: string;
	autogenerationStartTag: string
	autogenerationStartText: string
	autogenerationEndTag: string
	autogenerationEndText: string
}

const DEFAULT_SETTINGS: ContactsPluginSettings = {
	contactsGroup: 'obsidian',
	contactsFolder: 'Contacts',
	autogenerationStartTag: "START",
	autogenerationStartText: "Content BELOW this line is AUTOGENERATED and will be REPLACED.",
	autogenerationEndTag: "END",
	autogenerationEndText: "Content ABOVE this line is AUTOGENERATED and will be REPLACED."
}

export default class ContactsPlugin extends Plugin {
	settings: ContactsPluginSettings;

	async onload() {
		await this.loadSettings();

		// This adds a simple command that can be triggered anywhere
		this.addCommand({
			id: 'sync-contacts',
			name: 'Sync contacts',
			callback: async () =>  {
				if (!Platform.isMacOS) 
					return new Notice("Error: This plugin only works on MacOS");

				// Find/Create contacts folder
				if (await this.app.vault.adapter.exists(normalizePath(this.settings.contactsFolder)) == false)
					await this.app.vault.createFolder(this.settings.contactsFolder);

				new Notice("Syncing contacts in progress...");

				// Load contacts from MacOS "Contacts"
				let markdownResults = await new LoadContactsLogic(this.settings).loadContacts();

				// Save all contacts into file
				let promises: Array<Promise<any>> = [];
				for (let [filename, markdown] of markdownResults) {
					let prom: Promise<any>;

					let normPath = normalizePath(`${this.settings.contactsFolder}/${filename}.md`);
					let contactFile = await this.app.vault.getAbstractFileByPath(normPath);
					let newContactInfo = `<!-- ${this.settings.autogenerationStartTag} ${this.settings.autogenerationStartText} --> \n${markdown} \n<!-- ${this.settings.autogenerationEndTag} ${this.settings.autogenerationEndText} -->`;
					
					if (!(contactFile instanceof TFile)) {
						console.debug(`Creating ${filename}`);
						await this.app.vault.create(normPath, newContactInfo);
					} else {
						console.debug(`Updating ${filename}`);
						prom = this.app.vault.process(contactFile, (oldContent) => {
							let lines = oldContent.split("\n");
							
							let startReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationStartTag));
							let endReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationEndTag));

							let newLines = Array<string>();

							for (let i = Math.min(0, startReplacementIndex); i < lines.length; i++) {
								if (i == startReplacementIndex) {
									newLines.push(newContactInfo);
								} else if (i >= startReplacementIndex && i <= endReplacementIndex) {
									continue;
								} else {
									newLines.push(lines[i]);
								}
							}
							return newLines.join("\n");							
						});
						if (prom != undefined) {
							prom.catch((error) => {
								console.error(`Error syncing ${filename}`);
								console.error(error);
							});
							promises.push(prom);
						}
					}

				}
				Promise.all(promises).then(() => {
					new Notice("Contacts synced!");
				}).catch((error) => {
					new Notice("Error syncing contacts!");
					console.error(error);
				});
			}
		});

		// This adds a settings tab so the user can configure various aspects of the plugin
		this.addSettingTab(new SettingTab(this.app, this));
	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class SettingTab extends PluginSettingTab {
	plugin: ContactsPlugin;

	constructor(app: App, plugin: ContactsPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const {containerEl} = this;

		containerEl.empty();

		new Setting(containerEl)
			.setName('Contacts folder')
			.setDesc('Select the folder in which your contacts will stored')
			.addText(text => text
				.setPlaceholder('contacts')
				.setValue(this.plugin.settings.contactsFolder)
				.onChange(async (value) => {
					this.plugin.settings.contactsFolder = value;
					await this.plugin.saveSettings();
				}));
	}
}

interface VCard {
	fn?: { value: string }[];
	org?: { value: string[] }[];
	email?: { value: string, meta: { type: string[] } }[];
	tel?: { value: string, meta: { type: string[] } }[];
	adr?: { value: string[], meta: { type: string[] } }[];
	note?: { value: string }[];
	url?: { value: string, meta: { type: string[] }, namespace?: string }[];
	bday?: { value: string }[];
	categories?: { value: string }[];
	uid?: { value: string }[];
  }

class LoadContactsLogic {
	constructor(
		private settings: ContactsPluginSettings
	) {
		this.settings = settings;
	}

	async loadContacts(): Promise<Map<string, string>> {
		let vcard_data = await this.getVCardsStringFromApplescript();
  		let vcards = this.processVCardsString(vcard_data);
		
		let markdownMap = new Map<string, string>();

		for (let vcard of vcards) {
			let filename = vcard.fn?.[0]?.value;
			if (filename == undefined)
				continue;
		
			let markdown = this.vcardToMarkdown(vcard);

			markdownMap.set(filename, markdown);
		}

		return markdownMap;
	}

	private getVCardsStringFromApplescript(): Promise<string> {
		const group = this.settings.contactsGroup;
		const APPLESCRIPT = `
			set AppleScript's text item delimiters to ""

			tell application "Contacts"
				-- Check if the application is running, and if not, run it
				if not running then
					run
					set isRunning to false
					repeat while not isRunning
						set isRunning to exists (processes where name is "Contacts")
						if not isRunning then
							delay 0.1 -- Wait for 0.1 seconds before checking again
						end if
					end repeat
				end if


				set vCardText to (get vcard of every person in group "${group}") as text
			end tell
		`;

		return new Promise((resolve, reject) => {
			const cmd = spawn('osascript', ['-e', APPLESCRIPT]);

			let output = "";
			let errorOutput = "";

			cmd.stdout.on('data', (data) => {
				output += data;
			});

			cmd.stderr.on('data', (data) => {
				errorOutput += data;
			});

			cmd.on('close', (code) => {
				if (code != 0) {
					return reject(new Error(`Command failed with exit code ${code}: ${errorOutput}`));
				}
				resolve(output);
			});

			cmd.on('error', (error) => {
				reject(error);
			});
		});
	}
	
	private processVCardsString(vcard_data: string): Array<VCard> {
		const vCard = require("vcard-parser");

		const regex = /BEGIN:VCARD[\s\S]*?END:VCARD/g;
		const matches = vcard_data.match(regex);
		let vCards: Array<VCard> = [];

		if (matches) {
			matches.forEach((match, _) => {
				vCards.push(vCard.parse(match) as VCard);
			});
		}

		return vCards;
	}

	private vcardToMarkdown(vcard: VCard): string {
		let markdown = `## üë§ ${vcard.fn?.[0]?.value ?? 'Unknown'}\n`;
	  
		if (vcard.tel) markdown += vcard.tel.map(tel => `- ‚òéÔ∏è ${tel.meta?.type?.[0]?.toLowerCase() ?? 'Phone'}: [${tel.value}](tel:${tel.value})\n`).join('');
		if (vcard.email) markdown += `- üìß Email: [${vcard.email[0]?.value}](mailto:${vcard.email[0]?.value})\n`;
		if (vcard.url) markdown += `- üåê Website: [${vcard.url[0]?.value}](${vcard.url[0]?.value})\n`;
		if (vcard.adr) markdown += vcard.adr.map(adr => `- üè† Address: ${adr.value.filter(str => str.length > 0).join(", ")}\n`).join(''); // Joining address components by ', '
		if (vcard.bday) {
		  	const date = new Date(Date.parse(vcard.bday[0]?.value));
			markdown += `- üéÇ Birthday: ${date.toLocaleDateString()}\n`;
		}
		if (vcard.org) markdown += `- üè¢ Organization: ${vcard.org[0]?.value?.[0]}\n`;
		if (vcard.note) {
			let notes_lines = vcard.note[0]?.value.split("\n");
			markdown += `- üìù Notes: ${notes_lines[0]}\n`;
			for ( let line of notes_lines.slice(1))
				markdown += `\t${line}\n`;
		}
		//if (vcard.x_anniversary) markdown += `- üíç Anniversary: [[${vcard.x_anniversary[0]?.value}]]\n`; // Make sure this field exists in your VCard interface
		//if (vcard.geo) markdown += `- üìç Location: ${vcard.geo[0]?.value}\n`;
		//if (vcard.role) markdown += `- üíº Role: ${vcard.role[0]?.value}\n`;
		//if (vcard.title) markdown += `- üìõ Title: ${vcard.title[0]?.value}\n`;
		
		//if (vcard.x_gender) {
		//  const genderEmoji = vcard.x_gender[0]?.value?.toLowerCase() === 'f' ? "\u2640\ufe0f" : "\u2642\ufe0f";
		//  markdown += `- ${genderEmoji} Gender: ${vcard.x_gender[0]?.value}\n`;
		//}
	  
		//if (vcard.lang) markdown += `- üó£Ô∏è Language: ${vcard.lang[0]?.value}\n`;
	  
		return markdown.trim();
	}
	  
}